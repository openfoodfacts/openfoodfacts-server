<html><head><title>ProductOpener::Store</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<link rel="stylesheet" title="simple.min" type="text/css" href="../simple.min.css" media="all" >

</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.43,
  using Pod::Simple::PullParser v3.43,
  under Perl v5.038002 at Thu Feb 26 17:23:57 2026 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#write_json(%24file_path%2C_%24ref)'>write_json($file_path, $ref)</a>
    <li class='indexItem indexItem2'><a href='#write_canonical_json(%24file_path%2C_%24ref)'>write_canonical_json($file_path, $ref)</a>
    <li class='indexItem indexItem2'><a href='#read_json_raw(%24file_path)'>read_json_raw($file_path)</a>
    <li class='indexItem indexItem2'><a href='#read_json(%24file_path)'>read_json($file_path)</a>
    <li class='indexItem indexItem2'><a href='#store_object_(%24path%2C_%24ref)'>store_object ($path, $ref)</a>
    <li class='indexItem indexItem2'><a href='#retrieve_object(%24path)'>retrieve_object($path)</a>
    <li class='indexItem indexItem2'><a href='#retrieve_object_json(%24path)'>retrieve_object_json($path)</a>
    <li class='indexItem indexItem2'><a href='#object_exists(%24path)'>object_exists($path)</a>
    <li class='indexItem indexItem2'><a href='#object_path_exists(%24path)'>object_path_exists($path)</a>
    <li class='indexItem indexItem2'><a href='#move_object(%24old_path%2C_%24new_path)'>move_object($old_path, $new_path)</a>
    <li class='indexItem indexItem2'><a href='#link_object(%24name%2C_%24link)'>link_object($name, $link)</a>
    <li class='indexItem indexItem2'><a href='#remove_object(%24path)'>remove_object($path)</a>
    <li class='indexItem indexItem2'><a href='#object_iter(%24base_path%2C_%24name_pattern_%3D_undef%2C_%24exclude_path_pattern_%3D_undef%2C_%24skip_until_path_%3D_undef)'>object_iter($base_path, $name_pattern = undef, $exclude_path_pattern = undef, $skip_until_path = undef)</a>
    <li class='indexItem indexItem2'><a href='#store_config_(%24path%2C_%24ref)'>store_config ($path, $ref)</a>
    <li class='indexItem indexItem2'><a href='#retrieve_config(%24path)'>retrieve_config($path)</a>
  </ul>
</ul>
</div>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="write_json($file_path,_$ref)"
>write_json($file_path,
$ref)</a></h2>

<p>Write a JSON file with exclusive file locking</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="write_canonical_json($file_path,_$ref)"
>write_canonical_json($file_path,
$ref)</a></h2>

<p>Write a JSON file in canonical,
indented format without any file locking</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_json_raw($file_path)"
>read_json_raw($file_path)</a></h2>

<p>Reads from a JSON file with shared file locking.
Note returns JSON string,
not a hash.
Dies on error</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="read_json($file_path)"
>read_json($file_path)</a></h2>

<p>Reads from a JSON file with shared file locking.
Returns a hash.
Dies on error</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="store_object_($path,_$ref)"
>store_object ($path,
$ref)</a></h2>

<p>Serializes an object in our preferred object store,
removing it from legacy storage if it is present.
Tries to emulate [Storable](https://metacpan.org/dist/Storable/source/Storable.pm) behavior but uses die instead of croak</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="retrieve_object($path)"
>retrieve_object($path)</a></h2>

<p>Fetch the JSON object from storage and return as a hash ref.
Reverts to STO file if no JSON file exists.
Will die if JSON is malformed.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="retrieve_object_json($path)"
>retrieve_object_json($path)</a></h2>

<p>Fetch the JSON object from storage and return as a JSON string.
Reverts to STO file and serializes as JSON if no JSON file exists</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="object_exists($path)"
>object_exists($path)</a></h2>

<p>Indicates whether an object (STO or JSON) exists at the specified path</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="object_path_exists($path)"
>object_path_exists($path)</a></h2>

<p>Indicates whether an directory exists at the specified path</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="move_object($old_path,_$new_path)"
>move_object($old_path,
$new_path)</a></h2>

<p>Moves a single object or all objects in the path</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="link_object($name,_$link)"
>link_object($name,
$link)</a></h2>

<p>Makes the $link point to the data in the specified relative $path.
If the object at the $path is an sto file then an STO symbolic link will be created</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="remove_object($path)"
>remove_object($path)</a></h2>

<p>Removes an object or link to an object</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="object_iter($base_path,_$name_pattern_=_undef,_$exclude_path_pattern_=_undef,_$skip_until_path_=_undef)"
>object_iter($base_path,
$name_pattern = undef,
$exclude_path_pattern = undef,
$skip_until_path = undef)</a></h2>

<p>Iterates over the path returning a cursor that can return object paths whose name matches the $name_pattern regex and whose path does not match the $exclude_path_pattern.
If $skip_until_path is provided,
skips all object paths that are lexicographically less than $skip_until_path.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="store_config_($path,_$ref)"
>store_config ($path,
$ref)</a></h2>

<p>Serializes configuration information,
removing it from legacy storage if it is present.
JSON keys are sorted and indentation is used so files can be used in source control No locking is performed</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="retrieve_config($path)"
>retrieve_config($path)</a></h2>

<p>Same as retrieve_object but with no locking</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
