# This file is part of Product Opener.
#
# Product Opener
# Copyright (C) 2011-2020 Association Open Food Facts
# Contact: contact@openfoodfacts.org
# Address: 21 rue des Iles, 94100 Saint-Maur des Foss√©s, France
#
# Product Opener is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 NAME

ProductOpener::APITest - utility functions to interact with API

=head1 DESCRIPTION

=cut

package ProductOpener::APITest;

use ProductOpener::PerlStandards;
use Exporter qw< import >;

BEGIN {
	use vars qw(@ISA @EXPORT_OK %EXPORT_TAGS);
	@EXPORT_OK = qw(
		&construct_test_url
		&create_user
		&edit_user
		&edit_product
		&get_page
		&html_displays_error
		&login
		&mails_from_log
		&mail_to_text
		&new_client
		&post_form
		&tail_log_start
		&tail_log_read
		&wait_application_ready
		&wait_dynamic_front
		&wait_server

		$TEST_WEBSITE_URL
	);    # symbols to export on request
	%EXPORT_TAGS = (all => [@EXPORT_OK]);
}

use vars @EXPORT_OK;

use Test::More;
use LWP::UserAgent;
use HTTP::CookieJar::LWP;
use ProductOpener::TestDefaults qw/:all/;
use ProductOpener::Mail qw/ $LOG_EMAIL_START $LOG_EMAIL_END /;

use Carp qw/confess/;
use Clone qw/clone/;
use Data::Dump qw/dump/;
use File::Tail;

=head2 $TEST_WEBSITE_URL

Constant of the test website url

=cut

$TEST_WEBSITE_URL = "http://world.openfoodfacts.localhost";

=head2 wait_dynamic_front()

Wait for dynamic_front to be ready.
It's important because the application might fail because of that

=cut

sub wait_dynamic_front() {

	# simply try to access a resource generated by dynamicfront
	my $count = 0;
	while (1) {
		last if (-e "/opt/product-opener/html/images/icons/dist/barcode.svg");
		sleep 1;
		$count++;
		if (($count % 3) == 0) {
			print("Waiting for dynamicfront to be ready since $count seconds...\n");
		}
		confess("Waited too much for backend") if $count > 100;
	}
	return;
}


=head2 wait_server()

Wait for server to be ready.
It's important because the application might fail because of that

=cut

sub wait_server() {

	# simply try to access front page
	my $count = 0;
	my $ua = new_client();
	while (1) {
		my $response = $ua->get($TEST_WEBSITE_URL);
		last if $response->is_success;
		sleep 1;
		$count++;
		if (($count % 3) == 0) {
			print("Waiting for backend to be ready since more than $count seconds...\n");
		}
		confess("Waited too much for backend") if $count > 60;
	}
	return;
}

=head2 wait_application_ready()

Wait for server and dynamic front to be ready.
Run this at the beginning of every integration test

=cut

sub wait_application_ready() {
	wait_server();
	wait_dynamic_front();
}


=head2 new_client()

Reset user agent

=head3 return value

Return a user agent

=cut

sub new_client () {
	my $jar = HTTP::CookieJar::LWP->new;
	my $ua = LWP::UserAgent->new(cookie_jar => $jar);
	return $ua;
}

=head2 create_user($ua, $args_ref)

Call API to create a user

=head3 Arguments

=head4 $ua - user agent

=head4 $args_ref - fields

=cut

sub create_user ($ua, $args_ref) {
	my %fields = %{clone($args_ref)};
	my $tail = tail_log_start();
	my $response = $ua->post("$TEST_WEBSITE_URL/cgi/user.pl", Content => \%fields);
	if (not $response->is_success) {
		diag("Couldn't create user with " . dump(%fields) . "\n");
		diag explain $response;
		diag("\n\nLog4Perl Logs: \n" . tail_log_read($tail) . "\n\n");
		confess("\nResuming");
	}
	return $response;
}

=head2 edit_user($ua, $args_ref)

Call API to edit a user, see create_user

=cut

sub edit_user ($ua, $args_ref) {
	($args_ref->{type} eq "edit") or confess("Action type must be 'edit' in edit_user");
	# technically the same as create_user !
	return create_user($ua, $args_ref);
}

=head2 login($ua, $user_id, $password)

Login as a user

=cut

sub login ($ua, $user_id, $password) {
	my %fields = (
		user_id => $user_id,
		password => $password,
		".submit" => "submit",
	);
	my $response = $ua->post("$TEST_WEBSITE_URL/cgi/login.pl", Content => \%fields);
	if (not($response->is_success || $response->is_redirect)) {
		diag("Couldn't login with " . dump(\%fields) . "\n");
		diag explain $response;
		confess("Resuming");
	}
	return $response;
}

=head2 get_page ($ua, $url)

Get a page of the app

=head3 Arguments

=head4 $ua - user agent

=head4 $url - absolute url

=cut

sub get_page ($ua, $url) {
	my $response = $ua->get("$TEST_WEBSITE_URL$url");
	if (not $response->is_success) {
		diag("Couldn't get page $url\n");
		diag explain $response;
		confess("Resuming");
	}
	return $response;
}

=head2 post_form ($ua, $url, $fields_ref)

Post a form

=head3 Arguments

=head4 $ua - user agent

=head4 $url - absolute url

=head4 $fields_ref

Reference of a hash of fields to pass as the form result

=cut

sub post_form ($ua, $url, $fields_ref) {
	my $response = $ua->post("$TEST_WEBSITE_URL$url", Content => $fields_ref);
	if (not $response->is_success) {
		diag("Couldn't submit form $url with " . dump($fields_ref) . "\n");
		diag explain $response;
		confess("Resuming");
	}
	return $response;
}

=head2 edit_product($ua, $product_fields_ref)

Call the API to edit a product. If the product does not exist, it will be created.

=head3 Arguments

=head4 $ua - user agent

=head4 $product_fields_ref

Reference of a hash of product fields to pass to the API

=cut

sub edit_product ($ua, $product_fields) {
	my %fields;
	while (my ($key, $value) = each %{$product_fields}) {
		$fields{$key} = $value;
	}

	my $response = $ua->post("$TEST_WEBSITE_URL/cgi/product_jqm2.pl", Content => \%fields,);
	if (not $response->is_success) {
		diag("Couldn't create product with " . dump(\%fields) . "\n");
		diag explain $response;
		confess("Resuming");
	}
	return $response;
}

=head2 html_displays_error($page)

Return if a form displays errors

Most forms will return a 200 while displaying an error message.
This function assumes error_list.tt.html was used.
=cut

sub html_displays_error ($page) {
	return index($page, '<li class="error">') > -1;
}

=head2 construct_test_url()

Constructs the URL to send the HTTP request to for the API.

=head3 Arguments

Takes in two string arguments, One being the the target and other a prefix. 
The prefix could be simply the country code (eg: US for America or "World") OR something like ( {country-code}-{language-code} )

An example below
$target = "/product/35242200055"
$prefix= "world-fr"  

=head3 Return Value

Returns the constructed URL for the query 

For the example cited above this returns: "http://world-fr.openfoodfacts.localhost/product/35242200055"

=cut

sub construct_test_url ($target, $prefix) {
	my $link = "openfoodfacts.localhost";
	# my $api_end = "/api/v2/search?";
	my $api_end = "api/v2";

	if (index($target, $api_end) != -1) {
		$link .= "/cgi/display.pl?";
	}

	my $url = "http://${prefix}.${link}${target}";
	return $url;
}

=head2 tail_log_start($log_path)

Start monitoring a log file

=head3 Arguments

=head4 String $log_path

Defaults to /var/log/apache2/log4perl.log

=head3 Returns

An object to pass to tail_log_read to read

=cut

sub tail_log_start ($log_path = "/var/log/apache2/log4perl.log") {
	# we use nowait mode to avoid loosing time in test
	# but beware, this means we will have to manually call checkpending()
	# before reading
	my $tail = File::Tail->new(name => $log_path, nowait => 1);
	return $tail;
}

=head2 tail_log_read($tail)

Return all content written to a log file since last check

=head3 Arguments

=head4 $tail

Object returned by tail_log_start

=head3 Returns

Content as a string

=cut

sub tail_log_read ($tail) {
	# we want to do a nowait read,
	# but we bypass all the predict stuff from File::Tail
	# by directly using checkpending
	$tail->checkpending();
	my @contents = ();
	while (my $line = $tail->read()) {
		push @contents, $line;
	}
	return join "", @contents;
}

=head2 mails_from_log($text)
Retrieve mails in a log extract
=cut

sub mails_from_log ($text) {
	# use delimiter to get it (using non greedy match)
	# /g to match all and /s to treat \n as normal chars
	my @mails = ($text =~ /$LOG_EMAIL_START(.*?)$LOG_EMAIL_END/gs);
	return @mails;
}

=head2 mail_to_text($text)
Make mail more easy to search by removing some specific formatting

Especially we replace "3D=" for "=" and join line and their continuation
=head3 Arguments

=head4 $mail text of mail

=head3 Returns
Reformated text
=cut

sub mail_to_text ($mail) {
	my $text = $mail;
	# = at line ending indicates a continuation line
	$text =~ s/=\n//mg;
	# =3D means =
	$text =~ s/=3D/=/g;
	return $text;
}

1;
