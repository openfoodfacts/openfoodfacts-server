# This file is part of Product Opener.
#
# Product Opener
# Copyright (C) 2011-2020 Association Open Food Facts
# Contact: contact@openfoodfacts.org
# Address: 21 rue des Iles, 94100 Saint-Maur des Foss√©s, France
#
# Product Opener is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

=head1 NAME

ProductOpener::APITest - utility functions to interact with API

=head1 DESCRIPTION

=cut

package ProductOpener::APITest;

use ProductOpener::PerlStandards;
use Exporter qw< import >;

BEGIN {
	use vars qw(@ISA @EXPORT_OK %EXPORT_TAGS);
	@EXPORT_OK = qw(
		&create_user
		&new_client
		&wait_dynamic_front
		&edit_product
		&construct_test_url
		&execute_api_tests
	);    # symbols to export on request
	%EXPORT_TAGS = (all => [@EXPORT_OK]);
}

use vars @EXPORT_OK;

use ProductOpener::TestDefaults qw/:all/;
use ProductOpener::Test qw/:all/;

use Test::More;
use LWP::UserAgent;
use HTTP::CookieJar::LWP;
use Data::Dump qw/dump/;
use Encode;
use JSON::PP;

=head2 wait_dynamic_front()

Wait for dynamic_front to be ready.
It's important because the application might fail because of that

=cut

sub wait_dynamic_front() {

	# simply try to access a resource generated by dynamicfront
	my $count = 0;
	while (1) {
		last if (-e "/opt/product-opener/html/images/icons/dist/barcode.svg");
		sleep 1;
		$count++;
		if (($count % 3) == 0) {
			print("Waiting for dynamicfront to be ready since $count seconds...\n");
		}
	}
	return;
}

=head2 new_client()

Reset user agent

=head3 return value

Return a user agent

=cut

sub new_client () {
	my $jar = HTTP::CookieJar::LWP->new;
	my $ua = LWP::UserAgent->new(cookie_jar => $jar);
	return $ua;
}

=head2 create_user($ua, $args_ref)

Call API to create a user

=head3 Arguments

=head4 $ua - user agent

=head4 $args_ref - optional args to override defaults

=cut

sub create_user ($ua, $args_ref) {
	my %fields;
	while (my ($key, $value) = each %{$args_ref}) {
		$fields{$key} = $value;
	}
	my $response = $ua->post("http://world.openfoodfacts.localhost/cgi/user.pl", Content => \%fields,);
	if (not $response->is_success) {
		diag("Couldn't create user with " . dump(\%fields) . "\n");
		diag explain $response;
		die("Resuming");
	}
	return;
}

=head2 edit_product($ua, $product_fields_ref)

Call the API to edit a product. If the product does not exist, it will be created.

=head3 Arguments

=head4 $ua - user agent

=head4 $product_fields_ref

Reference of a hash of product fields to pass to the API

=cut

sub edit_product ($ua, $product_fields) {
	my %fields;
	while (my ($key, $value) = each %{$product_fields}) {
		$fields{$key} = $value;
	}

	my $response = $ua->post("http://world.openfoodfacts.localhost/cgi/product_jqm2.pl", Content => \%fields,);
	if (not $response->is_success) {
		diag("Couldn't create product with " . dump(\%fields) . "\n");
		diag explain $response;
		die("Resuming");
	}
	return;
}

=head2 construct_test_url()

Constructs the URL to send the HTTP request to for the API.

=head3 Arguments

Takes in two string arguments, One being the the target and other a prefix. 
The prefix could be simply the country code (eg: US for America or "World") OR something like ( {country-code}-{language-code} )

An example below
$target = "/product/35242200055"
$prefix= "world-fr"  

=head3 Return Value

Returns the constructed URL for the query 

For the example cited above this returns: "http://world-fr.openfoodfacts.localhost/product/35242200055"

=cut

sub construct_test_url ($target, $prefix) {
	my $link = "openfoodfacts.localhost";
	# my $api_end = "/api/v2/search?";
	my $api_end = "api/v2";

	if (index($target, $api_end) != -1) {
		$link .= "/cgi/display.pl?";
	}

	my $url = "http://${prefix}.${link}${target}";
	return $url;
}

=head2 execute_api_tests($file, $tests_ref)

Initialize tests and execute them.

=head3 Arguments

=head4 $file test file name

The *.t test files call execute_api_tests() with _FILE_ as the first parameter,
and the directories for the tests are derived from it.

=head4 $tests_ref reference to list of tests

The tests are in a structure like this:

my $tests_ref = (
    [
		{
			test_case => 'no-body',  # a description of the test, should be unique to easily retrieve which test failed
			method => 'POST',		# defaults to GET
			subdomain => 'world',	# defaults to "world"
			path => '/api/v3/product/12345678',
			query_string => '?some_param=some_value&some_other_param=some_other_value'	# optional
			form => { field_name => field_value, .. },	# optional, will not be sent if there is a body
			body => '{"some_json_field": "some_value"}',	# optional
		}
    ],
);

=cut

sub execute_api_tests ($file, $tests_ref) {

	my ($test_id, $test_dir, $expected_result_dir, $update_expected_results) = (init_expected_results($file));

	my $ua = LWP::UserAgent->new();

	foreach my $test_ref (@$tests_ref) {
		my $test_case = $test_ref->{test_case};
		my $url = construct_test_url($test_ref->{path} . ($test_ref->{query_string} || ''),
			$test_ref->{subdomain} || 'world');

		my $method = $test_ref->{method} || 'GET';

		my $response;

		# Send the request
		if ($method eq 'GET') {
			$response = $ua->get($url);
		}
		elsif ($method eq 'POST') {
			if (defined $test_ref->{body}) {
				$response = $ua->post(
					$url,
					Content => encode_utf8($test_ref->{body}),
					"Content-Type" => "application/json; charset=utf-8"
				);
			}
			elsif (defined $test_ref->{form}) {
				$response = $ua->post($url, Content => $test_ref->{form});
			}
			else {
				$response = $ua->post($url);
			}
		}

		# Check if the request was successful
		if (not $response->is_success) {
			diag("The request to $url failed: " . $response->status_line);
			fail($test_case);
		}
		else {

			# Check that we got a JSON response
			my $json = $response->decoded_content;

			my $decoded_json;
			eval {
				$decoded_json = decode_json($json);
				1;
			} or do {
				my $json_decode_error = $@;
				diag("The $method request to $url returned a response that is not valid JSON: $json_decode_error");
				diag("Response content: " . $json);
				fail($test_case);
				next;
			};

			# normalize for comparison
			if (defined $decoded_json->{'products'}) {
				normalize_products_for_test_comparison($decoded_json->{'products'});
			}
			if (defined $decoded_json->{'product'}) {
				normalize_product_for_test_comparison($decoded_json->{'product'});
			}

			is(
				compare_to_expected_results(
					$decoded_json, "$expected_result_dir/$test_case.json",
					$update_expected_results
				),
				1,
			);
		}
	}
	return;
}

1;
